import { Drawing } from '../document/Drawing';
import { Entity } from '../entities/Entity';
import { Line } from '../entities/Line';
import { Circle } from '../entities/Circle';
import { Arc } from '../entities/Arc';
import { Polyline } from '../entities/Polyline';
import { Vector2 } from '../Vector2';

/**
 * SVG export options
 */
export interface SVGExportOptions {
  width?: number;
  height?: number;
  padding?: number;
  backgroundColor?: string;
  strokeWidth?: number;
  fitToPage?: boolean;
}

/**
 * SVGExporter - Export drawings to SVG format
 */
export class SVGExporter {
  private options: Required<SVGExportOptions>;

  constructor(options: SVGExportOptions = {}) {
    this.options = {
      width: options.width || 800,
      height: options.height || 600,
      padding: options.padding || 20,
      backgroundColor: options.backgroundColor || '#1e1e1e',
      strokeWidth: options.strokeWidth || 2,
      fitToPage: options.fitToPage !== false,
    };
  }

  /**
   * Export drawing to SVG string
   */
  export(drawing: Drawing): string {
    const bounds = drawing.getBounds();
    if (!bounds) {
      return this.createEmptySVG();
    }

    // Calculate viewport
    const { viewBox, transform } = this.calculateViewBox(bounds);

    const svg: string[] = [];

    // SVG header
    svg.push(
      `<?xml version="1.0" encoding="UTF-8"?>`,
      `<svg xmlns="http://www.w3.org/2000/svg"`,
      `     width="${this.options.width}"`,
      `     height="${this.options.height}"`,
      `     viewBox="${viewBox}">`,
      '',
      `  <!-- Generated by NEOcad -->`,
      `  <!-- Drawing: ${drawing.getName()} -->`,
      ''
    );

    // Background
    svg.push(
      `  <rect width="100%" height="100%" fill="${this.options.backgroundColor}"/>`
    );

    // Create group with transform
    svg.push(`  <g transform="${transform}">`);

    // Export entities
    for (const entity of drawing.getEntities()) {
      if (!entity.isVisible()) continue;

      const entitySVG = this.exportEntity(entity);
      if (entitySVG) {
        svg.push(`    ${entitySVG}`);
      }
    }

    // Close group and SVG
    svg.push(`  </g>`, `</svg>`);

    return svg.join('\n');
  }

  /**
   * Calculate SVG viewBox
   */
  private calculateViewBox(bounds: { min: Vector2; max: Vector2 }): {
    viewBox: string;
    transform: string;
  } {
    const width = bounds.max.x - bounds.min.x;
    const height = bounds.max.y - bounds.min.y;

    if (this.options.fitToPage) {
      // Fit to page with padding
      const availableWidth = this.options.width - this.options.padding * 2;
      const availableHeight = this.options.height - this.options.padding * 2;

      const scaleX = availableWidth / width;
      const scaleY = availableHeight / height;
      const scale = Math.min(scaleX, scaleY);

      const scaledWidth = width * scale;
      const scaledHeight = height * scale;

      const offsetX = (this.options.width - scaledWidth) / 2;
      const offsetY = (this.options.height - scaledHeight) / 2;

      return {
        viewBox: `0 0 ${this.options.width} ${this.options.height}`,
        transform: `translate(${offsetX}, ${offsetY}) scale(${scale}, ${-scale}) translate(${-bounds.min.x}, ${-bounds.max.y})`,
      };
    } else {
      // Use drawing coordinates directly
      return {
        viewBox: `${bounds.min.x} ${-bounds.max.y} ${width} ${height}`,
        transform: `scale(1, -1)`,
      };
    }
  }

  /**
   * Export single entity
   */
  private exportEntity(entity: Entity): string | null {
    const color = entity.getColor() || '#ffffff';
    const strokeWidth = (entity.getLineWeight() || 1) * this.options.strokeWidth;
    const commonAttrs = `stroke="${color}" stroke-width="${strokeWidth}" fill="none"`;

    if (entity instanceof Line) {
      return this.exportLine(entity, commonAttrs);
    } else if (entity instanceof Circle) {
      return this.exportCircle(entity, commonAttrs);
    } else if (entity instanceof Arc) {
      return this.exportArc(entity, commonAttrs);
    } else if (entity instanceof Polyline) {
      return this.exportPolyline(entity, commonAttrs);
    }

    return null;
  }

  /**
   * Export LINE
   */
  private exportLine(line: Line, attrs: string): string {
    const start = line.getStart();
    const end = line.getEnd();

    return `<line x1="${start.x}" y1="${start.y}" x2="${end.x}" y2="${end.y}" ${attrs}/>`;
  }

  /**
   * Export CIRCLE
   */
  private exportCircle(circle: Circle, attrs: string): string {
    const center = circle.getCenter();
    const radius = circle.getRadius();

    return `<circle cx="${center.x}" cy="${center.y}" r="${radius}" ${attrs}/>`;
  }

  /**
   * Export ARC
   */
  private exportArc(arc: Arc, attrs: string): string {
    const center = arc.getCenter();
    const radius = arc.getRadius();
    const startAngle = arc.getStartAngle();
    const endAngle = arc.getEndAngle();

    // Calculate start and end points
    const start = new Vector2(
      center.x + Math.cos(startAngle) * radius,
      center.y + Math.sin(startAngle) * radius
    );

    const end = new Vector2(
      center.x + Math.cos(endAngle) * radius,
      center.y + Math.sin(endAngle) * radius
    );

    // Calculate large arc flag
    let sweep = endAngle - startAngle;
    if (arc.isCounterClockwise()) {
      if (sweep < 0) sweep += 2 * Math.PI;
    } else {
      if (sweep > 0) sweep -= 2 * Math.PI;
      sweep = -sweep;
    }

    const largeArc = sweep > Math.PI ? 1 : 0;
    const sweepFlag = arc.isCounterClockwise() ? 1 : 0;

    return `<path d="M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArc} ${sweepFlag} ${end.x} ${end.y}" ${attrs}/>`;
  }

  /**
   * Export POLYLINE
   */
  private exportPolyline(polyline: Polyline, attrs: string): string {
    const vertices = polyline.getVertices();
    if (vertices.length < 2) return '';

    const points = vertices.map((v) => `${v.x},${v.y}`).join(' ');

    if (polyline.isClosed()) {
      return `<polygon points="${points}" ${attrs}/>`;
    } else {
      return `<polyline points="${points}" ${attrs}/>`;
    }
  }

  /**
   * Create empty SVG
   */
  private createEmptySVG(): string {
    return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     width="${this.options.width}"
     height="${this.options.height}">
  <rect width="100%" height="100%" fill="${this.options.backgroundColor}"/>
  <text x="50%" y="50%" text-anchor="middle" fill="#666">
    Empty Drawing
  </text>
</svg>`;
  }

  /**
   * Static export method
   */
  static export(drawing: Drawing, options?: SVGExportOptions): string {
    const exporter = new SVGExporter(options);
    return exporter.export(drawing);
  }

  /**
   * Save to file
   */
  static async saveToFile(
    drawing: Drawing,
    filename: string,
    options?: SVGExportOptions
  ): Promise<void> {
    const svg = this.export(drawing, options);

    // Ensure .svg extension
    if (!filename.endsWith('.svg')) {
      filename += '.svg';
    }

    const blob = new Blob([svg], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  /**
   * Export to data URL
   */
  static toDataURL(drawing: Drawing, options?: SVGExportOptions): string {
    const svg = this.export(drawing, options);
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  }
}
